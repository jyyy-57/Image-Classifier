1. 修改Langchain4JMcpClientFactory.java


java
/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a proprietary license.
 * See the License.txt file for more information. You may not use this file
 * except in compliance with the proprietary license.
 */
package io.camunda.connector.agenticai.mcp.client.framework.langchain4j;

import dev.langchain4j.mcp.client.DefaultMcpClient;
import dev.langchain4j.mcp.client.McpClient;
import dev.langchain4j.mcp.client.transport.McpTransport;
import dev.langchain4j.mcp.client.transport.http.HttpMcpTransport;
import dev.langchain4j.mcp.client.transport.stdio.StdioMcpTransport;
import io.camunda.connector.agenticai.mcp.client.McpClientFactory;
import io.camunda.connector.agenticai.mcp.client.configuration.McpClientConfigurationProperties;
import io.camunda.connector.agenticai.mcp.client.configuration.McpClientConfigurationProperties.McpClientConfiguration;
import java.util.Optional;

public class Langchain4JMcpClientFactory implements McpClientFactory<McpClient> {

  @Override
  public McpClient createClient(String clientId, McpClientConfiguration config) {
    final var transport = createTransport(config);
    final var builder = new DefaultMcpClient.Builder().key(clientId).transport(transport);

    Optional.ofNullable(config.initializationTimeout()).ifPresent(builder::initializationTimeout);
    Optional.ofNullable(config.toolExecutionTimeout()).ifPresent(builder::toolExecutionTimeout);
    Optional.ofNullable(config.reconnectInterval()).ifPresent(builder::reconnectInterval);

    return builder.build();
  }

  // 修改createTransport方法以支持三种传输类型
  private McpTransport createTransport(McpClientConfiguration config) {
    // 检查哪种传输配置不为null
    if (config.stdio() != null) {
      return createStdioTransport(config.stdio());
    } else if (config.http() != null) {
      return createHttpTransport(config.http());
    } else if (config.streamableHttp() != null) {
      return createStreamableHttpTransport(config.streamableHttp());
    } else {
      throw new IllegalArgumentException("No valid transport configuration found in McpClientConfiguration");
    }
  }

  private McpTransport createStdioTransport(
      McpClientConfigurationProperties.StdioMcpClientTransportConfiguration stdio) {
    return new StdioMcpTransport.Builder()
        .command(stdio.command())
        .environment(stdio.env())
        .logEvents(stdio.logEvents())
        .build();
  }

  private McpTransport createHttpTransport(
      McpClientConfigurationProperties.HttpMcpClientTransportConfiguration http) {
    return new HttpMcpTransport.Builder()
        .sseUrl(http.sseUrl())
        .timeout(http.timeout())
        .logRequests(http.logRequests())
        .logResponses(http.logResponses())
        .build();
  }

  // 新增streamable HTTP传输创建方法
  private McpTransport createStreamableHttpTransport(
      McpClientConfigurationProperties.StreamableHttpMcpClientTransportConfiguration streamableHttp) {
    // 注意：这里需要实现StreamableHttpMcpTransport类
    // 这是一个新的传输实现，需要创建
    return new StreamableHttpMcpTransport.Builder()
        .baseUrl(streamableHttp.baseUrl())
        .headers(streamableHttp.headers())
        .timeout(streamableHttp.timeout())
        .readTimeout(streamableHttp.readTimeout())
        .streamingContentType(streamableHttp.streamingContentType())
        .bufferSize(streamableHttp.bufferSize())
        .flushInterval(streamableHttp.flushInterval())
        .logRequests(streamableHttp.logRequests())
        .logResponses(streamableHttp.logResponses())
        .build();
  }
}
2. 修改Langchain4JMcpRemoteClientHandler.java


java
/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a proprietary license.
 * See the License.txt file for more information. You may not use this file
 * except in compliance with the proprietary license.
 */
package io.camunda.connector.agenticai.mcp.client.framework.langchain4j;

import com.fasterxml.jackson.databind.ObjectMapper;
import dev.langchain4j.mcp.client.McpClient;
import io.camunda.connector.agenticai.mcp.client.McpRemoteClientHandler;
import io.camunda.connector.agenticai.mcp.client.McpRemoteClientRegistry;
import io.camunda.connector.agenticai.mcp.client.McpRemoteClientRegistry.McpRemoteClientIdentifier;
import io.camunda.connector.agenticai.mcp.client.McpToolNameFilter;
import io.camunda.connector.agenticai.mcp.client.model.McpClientOperation;
import io.camunda.connector.agenticai.mcp.client.model.McpRemoteClientRequest;
import io.camunda.connector.agenticai.mcp.client.model.result.McpClientResult;
import io.camunda.connector.api.outbound.OutboundConnectorContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Langchain4JMcpRemoteClientHandler implements McpRemoteClientHandler {

  private static final Logger LOGGER =
      LoggerFactory.getLogger(Langchain4JMcpRemoteClientHandler.class);

  private final ObjectMapper objectMapper;
  private final McpRemoteClientRegistry<McpClient> remoteClientRegistry;
  private final Langchain4JMcpClientExecutor clientExecutor;

  public Langchain4JMcpRemoteClientHandler(
      ObjectMapper objectMapper,
      McpRemoteClientRegistry<McpClient> remoteClientRegistry,
      Langchain4JMcpClientExecutor clientExecutor) {
    this.objectMapper = objectMapper;
    this.remoteClientRegistry = remoteClientRegistry;
    this.clientExecutor = clientExecutor;
  }

  @Override
  public McpClientResult handle(OutboundConnectorContext context, McpRemoteClientRequest request) {
    final var clientId = McpRemoteClientIdentifier.from(context);
    final var operation =
        objectMapper.convertValue(request.data().operation(), McpClientOperation.class);
    final var toolNameFilter = McpToolNameFilter.from(request.data().tools());

    // 获取连接配置并记录连接类型
    final var connectionConfig = request.data().connection();
    LOGGER.debug("MCP({}): Handling operation '{}' on remote client with connection type: {}", 
        clientId, operation.method(), connectionConfig.getClass().getSimpleName());

    // 使用新的getClient方法，支持ConnectionConfiguration接口
    final var client = remoteClientRegistry.getClient(clientId, connectionConfig);

    return clientExecutor.execute(client, operation, toolNameFilter);
  }
}
3. Langchain4JMcpClientExecutor.java和Langchain4JMcpClientHandler.java
这两个文件不需要修改，因为：
	•	Langchain4JMcpClientExecutor: 它只处理MCP协议层面的操作，不关心底层传输方式
	•	Langchain4JMcpClientHandler: 它处理Runtime配置的客户端，传输类型在工厂层面处理
4. 需要创建的新文件：StreamableHttpMcpTransport.java


java
/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a proprietary license.
 * See the License.txt file for more information. You may not use this file
 * except in compliance with the proprietary license.
 */
package io.camunda.connector.agenticai.mcp.client.framework.langchain4j;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import dev.langchain4j.agent.tool.ToolExecutionRequest;
import dev.langchain4j.mcp.client.transport.McpTransport;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StreamableHttpMcpTransport implements McpTransport {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(StreamableHttpMcpTransport.class);
    
    private final String baseUrl;
    private final Map<String, String> headers;
    private final Duration timeout;
    private final Duration readTimeout;
    private final String streamingContentType;
    private final int bufferSize;
    private final Duration flushInterval;
    private final boolean logRequests;
    private final boolean logResponses;
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;

    private StreamableHttpMcpTransport(Builder builder) {
        this.baseUrl = builder.baseUrl;
        this.headers = builder.headers;
        this.timeout = builder.timeout;
        this.readTimeout = builder.readTimeout;
        this.streamingContentType = builder.streamingContentType;
        this.bufferSize = builder.bufferSize;
        this.flushInterval = builder.flushInterval;
        this.logRequests = builder.logRequests;
        this.logResponses = builder.logResponses;
        this.objectMapper = new ObjectMapper();
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(timeout)
            .build();
    }

    @Override
    public String executeTool(ToolExecutionRequest request) {
        try {
            // 构建MCP协议请求
            Map<String, Object> mcpRequest = Map.of(
                "jsonrpc", "2.0",
                "method", "tools/call",
                "params", Map.of(
                    "name", request.name(),
                    "arguments", objectMapper.readValue(request.arguments(), Map.class)
                )
            );

            return sendStreamableRequest(mcpRequest);
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to execute tool via streamable HTTP", e);
        }
    }

    @Override
    public dev.langchain4j.agent.tool.ToolSpecification[] listTools() {
        try {
            Map<String, Object> mcpRequest = Map.of(
                "jsonrpc", "2.0",
                "method", "tools/list",
                "params", Map.of()
            );

            String response = sendStreamableRequest(mcpRequest);
            // 解析并转换为ToolSpecification数组
            // 这里需要根据实际的响应格式来实现
            return new dev.langchain4j.agent.tool.ToolSpecification[0];
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to list tools via streamable HTTP", e);
        }
    }

    private String sendStreamableRequest(Map<String, Object> mcpRequest) throws Exception {
        String requestBody = objectMapper.writeValueAsString(mcpRequest);
        
        if (logRequests) {
            LOGGER.debug("Streamable HTTP Request: {}", requestBody);
        }

        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/rpc"))
            .header("Content-Type", "application/json")
            .header("Accept", streamingContentType)
            .timeout(timeout)
            .POST(HttpRequest.BodyPublishers.ofString(requestBody));

        // 添加自定义headers
        headers.forEach(requestBuilder::header);

        HttpRequest httpRequest = requestBuilder.build();

        HttpResponse<Stream<String>> response = httpClient.send(
            httpRequest, 
            HttpResponse.BodyHandlers.ofLines()
        );

        if (response.statusCode() != 200) {
            throw new RuntimeException("HTTP request failed with status: " + response.statusCode());
        }

        return processStreamingResponse(response);
    }

    private String processStreamingResponse(HttpResponse<Stream<String>> response) {
        StringBuilder result = new StringBuilder();
        AtomicBoolean completed = new AtomicBoolean(false);

        response.body().forEach(line -> {
            if (!line.trim().isEmpty() && !completed.get()) {
                try {
                    if (logResponses) {
                        LOGGER.debug("Streamable HTTP Response chunk: {}", line);
                    }

                    JsonNode chunk = objectMapper.readTree(line);
                    
                    if (chunk.has("error")) {
                        throw new RuntimeException("Server error: " + chunk.get("error"));
                    }
                    
                    if (chunk.has("result")) {
                        JsonNode resultNode = chunk.get("result");
                        
                        if (resultNode.has("content")) {
                            result.append(resultNode.get("content").asText());
                        }
                        
                        if (resultNode.has("isError") && resultNode.get("isError").asBoolean()) {
                            completed.set(true);
                            throw new RuntimeException("Tool execution error");
                        }
                        
                        if (resultNode.has("done") && resultNode.get("done").asBoolean()) {
                            completed.set(true);
                        }
                    }
                    
                } catch (JsonProcessingException e) {
                    throw new RuntimeException("Failed to parse streaming response", e);
                }
            }
        });

        return result.toString();
    }

    public static class Builder {
        private String baseUrl;
        private Map<String, String> headers = Map.of();
        private Duration timeout = Duration.ofSeconds(30);
        private Duration readTimeout = Duration.ofSeconds(45);
        private String streamingContentType = "application/x-ndjson";
        private int bufferSize = 1024;
        private Duration flushInterval = Duration.ofSeconds(1);
        private boolean logRequests = false;
        private boolean logResponses = false;

        public Builder baseUrl(String baseUrl) {
            this.baseUrl = baseUrl;
            return this;
        }

        public Builder headers(Map<String, String> headers) {
            this.headers = headers;
            return this;
        }

        public Builder timeout(Duration timeout) {
            this.timeout = timeout;
            return this;
        }

        public Builder readTimeout(Duration readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public Builder streamingContentType(String streamingContentType) {
            this.streamingContentType = streamingContentType;
            return this;
        }

        public Builder bufferSize(int bufferSize) {
            this.bufferSize = bufferSize;
            return this;
        }

        public Builder flushInterval(Duration flushInterval) {
            this.flushInterval = flushInterval;
            return this;
        }

        public Builder logRequests(boolean logRequests) {
            this.logRequests = logRequests;
            return this;
        }

        public Builder logResponses(boolean logResponses) {
            this.logResponses = logResponses;
            return this;
        }

        public StreamableHttpMcpTransport build() {
            if (baseUrl == null || baseUrl.isBlank()) {
                throw new IllegalArgumentException("baseUrl is required");
            }
            return new StreamableHttpMcpTransport(this);
        }
    }
}
5. 更新导入语句
在修改的文件中需要添加适当的导入语句：


java
// 在Langchain4JMcpClientFactory.java中添加
import io.camunda.connector.agenticai.mcp.client.framework.langchain4j.StreamableHttpMcpTransport;

// 在Langchain4JMcpRemoteClientHandler.java中可能需要添加
import io.camunda.connector.agenticai.mcp.client.model.McpRemoteClientRequest.McpRemoteClientRequestData.ConnectionConfiguration;
